# 变量

<!-- 这部分应该解释变量是如何默认为不可变的 -->
<!-- immutable_vars:example:start -->

在 Sway 中，默认情况下，变量是 _不可变的_。这意味着一旦变量被声明，默认情况下，它的值就不能改变。这是 Sway 鼓励安全编程的一种方式，许多现代语言也采用了相同的默认设置。

<!-- immutable_vars:example:end -->

让我们详细看看变量。

## 声明一个变量

让我们看一个变量声明：

```sway
let foo = 5;
```

太好了！我们刚刚声明了一个变量 `foo`。关于 `foo`，我们知道什么呢？

1. 它是不可变的。
2. 它的值是 `5`。
3. 它的类型是 `u64`，即 64 位无符号整数。

`u64` 是默认的数字类型，表示 64 位无符号整数。有关更多详情，请参阅 [内置类型](./built_in_types.md) 部分。

我们也可以创建一个可变变量。让我们看一下：

```sway
let mut foo = 5;
foo = 6;
```

现在，`foo` 是可变的，对数字 `6` 的重新赋值是有效的。也就是说，我们允许 _改变_ 变量 `foo` 的值。

当对可变变量赋值时，赋值语句的右侧在左侧之前被评估。在下面的例子中，可变变量 `i` 将首先被增加，结果值 `1` 将被存储到 `array[1]`，因此 `array` 将被更改为 `[0, 1, 0]`。

```sway
let mut array = [0, 0, 0];
let mut i = 0;

array[i] = {
i += 1;
i
};
```

## 类型注解

<!-- 这部分应该解释类型注解 -->
<!-- type_annotations:example:start -->

变量声明可以包含一个 _类型注解_。类型注解的作用是声明变量的类型，除了值之外。

<!-- type_annotations:example:end -->

让我们来看一下：

```sway
let foo: u32 = 5;
```

我们刚刚声明了变量 `foo` 的 _类型_ 为 `u32`，这是一个无符号的 32 位整数。让我们再看几个类型注解：

```sway
let bar: str[4] = \_\_to_str_array("sway");
let baz: bool = true;
```

<!-- 这部分应该解释如果存在类型冲突会发生什么 -->
<!-- type_conflict:example:start -->

如果声明的值无法赋值给声明的类型，编译器将生成错误。

<!-- type_conflict:example:end -->
